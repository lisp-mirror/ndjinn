(in-package #:net.mfiano.lisp.pyx)

(defstruct (picker
            (:predicate nil)
            (:copier nil))
  (start (v3:vec) :type v3:vec)
  (end (v3:vec) :type v3:vec))

(defgeneric pick-collider-shape (picker shape)
  (:method (picker shape)))

(defmethod pick-collider-shape (picker (shape collider-shape/sphere))
  (with-slots (%entity %center %radius) shape
    (let* ((start (picker-start picker))
           (end (picker-end picker))
           (line (v3:- end start))
           (d (v3:normalize line))
           (m (v3:- start (transform-point %entity %center)))
           (b (v3:dot m d))
           (c (- (v3:dot m m) (expt %radius 2))))
      (unless (and (plusp c) (plusp b))
        (let ((discriminant (- (expt b 2) c)))
          (unless (minusp discriminant)
            (let ((x (max 0.0 (- (- b) (sqrt discriminant)))))
              (when (<= x (v3:length line))
                x))))))))

(defmethod pick-collider-shape (picker (shape collider-shape/box))
  (with-slots (%entity %center %min-extent %max-extent) shape
    (let* ((start (v3:- (transform-point %entity
                                         (picker-start picker)
                                         :space :world)
                        %center))
           (end (v3:- (transform-point %entity
                                       (picker-end picker)
                                       :space :world)
                      %center))
           (vec (v3:- end start))
           (d (v3:normalize vec))
           (t-min 0f0)
           (t-max (v3:length vec)))
      (dotimes (i 3)
        (let ((p-i (aref start i))
              (min-i (aref %min-extent i))
              (max-i (aref %max-extent i)))
          (if (< (abs (aref d i)) 1e-7)
              (when (or (< p-i min-i)
                        (> p-i max-i))
                (return-from pick-collider-shape nil))
              (let* ((inv-d (/ (aref d i)))
                     (t1 (* (- min-i p-i) inv-d))
                     (t2 (* (- max-i p-i) inv-d)))
                (when (> t1 t2)
                  (rotatef t1 t2))
                (setf t-min (max t-min t1)
                      t-max (min t-max t2))
                (when (> t-min t-max)
                  (return-from pick-collider-shape nil))))))
      t-min)))

(defun update-picker ()
  (u:mvlet ((x y dx dy (get-mouse-position)))
    (u:when-let* ((viewport (get-viewport-by-coordinates x y))
                  (start (picker-start (picker viewport)))
                  (end (picker-end (picker viewport)))
                  (camera (camera viewport))
                  (view (camera/view camera))
                  (proj (camera/projection camera))
                  (viewport (v4:vec (x viewport)
                                    (y viewport)
                                    (width viewport)
                                    (height viewport))))
      (math:unproject! start (v3:vec x y) view proj viewport)
      (math:unproject! end (v3:vec x y 1) view proj viewport))))

(defun pick-entity ()
  (u:mvlet* ((scene (current-scene =context=))
             (mx my (get-mouse-position))
             (viewport (get-viewport-by-coordinates mx my))
             (picker (picker viewport))
             (picked nil))
    (update-picker)
    (u:do-hash-values (v (active (collision-system scene)))
      (u:do-hash-keys (k v)
        (u:when-let ((n (pick-collider-shape picker (collider/shape k))))
          (when (collider/pickable k)
            (push (cons n k) picked)))))
    (when picked
      (let* ((collider (cdar (stable-sort picked #'< :key #'car)))
             (entity (collider/owner collider)))
        (setf (picked-entity scene) entity)
        (on-collision-picked (collider/layer collider) entity)
        entity))))

(defun entity-picked-p (entity)
  (eq entity (picked-entity (current-scene =context=))))
