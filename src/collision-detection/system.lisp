(in-package #:net.mfiano.lisp.pyx)

(defclass collision-system ()
  ((%spec :reader spec
          :initarg :spec)
   (%registered :reader registered
                :initform (u:dict #'eq))
   (%deregistered :reader deregistered
                  :initform (u:dict #'eq))
   (%active :reader active
            :initform (u:dict #'eq))
   (%contacts :reader contacts
              :initform (u:dict #'eq))
   (%buffer :reader buffer
            :initform (make-array 8 :adjustable t :fill-pointer t))))

(defun make-collision-system (plan-name)
  (u:if-let ((spec (u:href =meta/collider-plans= plan-name)))
    (let ((system (make-instance 'collision-system :spec spec)))
      (dolist (layer (layers spec))
        (setf (u:href (registered system) layer) (u:dict #'eq)
              (u:href (deregistered system) layer) (u:dict #'eq)
              (u:href (active system) layer) (u:dict #'eq)))
      system)
    (error "Collider plan ~s not found." plan-name)))

(defun register-collider (collider layer)
  (let* ((system (collision-system (current-scene =context=)))
         (registered (registered system)))
    (unless (u:href registered layer)
      (error "Collider ~s has a layer that is not in the scene's collider ~
              plan."
             collider))
    (setf (u:href registered layer collider) collider)))

(defun deregister-collider (collider layer)
  (let* ((system (collision-system (current-scene =context=)))
         (deregistered (deregistered system)))
    (remove-collider-contacts system collider)
    (setf (u:href deregistered layer collider) collider)))

(defun collider-contact-p (system collider1 collider2)
  (let ((contacts (contacts system)))
    (when (u:href contacts collider1)
      (u:href contacts collider1 collider2))))

(defun collider-contact-enter (system collider1 collider2)
  (let ((contacts (contacts system)))
    (unless (u:href contacts collider1)
      (setf (u:href contacts collider1) (u:dict #'eq)))
    (setf (u:href contacts collider1 collider2) collider2)
    (unless (u:href contacts collider2)
      (setf (u:href contacts collider2) (u:dict #'eq)))
    (setf (u:href contacts collider2 collider1) collider1)
    (%on-collision-enter collider1 collider2)
    (%on-collision-enter collider2 collider1)))

(defun collider-contact-continue (collider1 collider2)
  (%on-collision-continue collider1 collider2)
  (%on-collision-continue collider2 collider1))

(defun collider-contact-exit (system collider1 collider2)
  (let ((contacts (contacts system)))
    (u:when-let ((table2 (u:href contacts collider1)))
      (remhash collider2 table2)
      (when (zerop (hash-table-count table2))
        (remhash collider1 contacts)))
    (u:when-let ((table1 (u:href contacts collider2)))
      (remhash collider1 table1)
      (when (zerop (hash-table-count table1))
        (remhash collider2 contacts)))
    (%on-collision-exit collider1 collider2)
    (%on-collision-exit collider2 collider1)))

(defun remove-collider-contacts (system collider)
  (let ((contacts (contacts system)))
    (u:when-let ((colliders (u:href contacts collider)))
      (u:do-hash-keys (k colliders)
        (when (collider-contact-p system collider k)
          (collider-contact-exit system collider k))))))

(defun compute-collider-contact (system collider1 collider2)
  (u:when-let ((shape1 (collider/shape collider1))
               (shape2 (collider/shape collider2)))
    (let ((collided-p (collide-p shape1 shape2))
          (contact-p (collider-contact-p system collider1 collider2)))
      (cond
        ((and collided-p contact-p)
         (collider-contact-continue collider1 collider2))
        ((and collided-p (not contact-p))
         (collider-contact-enter system collider1 collider2))
        ((and (not collided-p) contact-p)
         (collider-contact-exit system collider1 collider2))))))

(defun compute-collisions/active (system)
  (let* ((active (active system))
         (buffer (buffer system))
         (table (table (spec system))))
    (dolist (collider1-layer (layers (spec system)))
      (dolist (collider2-layer (u:href table collider1-layer))
        (if (eq collider1-layer collider2-layer)
            (u:when-let ((colliders (u:href active collider1-layer)))
              (setf (fill-pointer buffer) 0)
              (u:do-hash-keys (k colliders)
                (vector-push-extend k buffer))
              (when (>= (length buffer) 2)
                (u:map-combinations
                 (lambda (x)
                   (compute-collider-contact system (aref x 0) (aref x 1)))
                 buffer
                 :length 2
                 :copy nil)))
            (u:do-hash-keys (k1 (u:href active collider1-layer))
              (u:do-hash-keys (k2 (u:href active collider2-layer))
                (compute-collider-contact system k1 k2))))))))

(defun compute-collisions/registered (system)
  (let* ((active (active system))
         (registered (registered system))
         (table (table (spec system))))
    (dolist (c1-layer (layers (spec system)))
      (let ((layer-registered (u:href registered c1-layer)))
        (u:do-hash-keys (c1 layer-registered)
          (remhash c1 layer-registered)
          (unless (u:href active c1)
            (let ((c2-layers (u:href table c1-layer)))
              (dolist (c2-layer c2-layers)
                (u:do-hash-keys (c2 (u:href active c2-layer))
                  (compute-collider-contact system c1 c2)))
              (setf (u:href active c1-layer c1) c1))))))))

(defun compute-collisions/deregistered (system)
  (let* ((active (active system))
         (registered (registered system))
         (deregistered (deregistered system)))
    (dolist (layer (layers (spec system)))
      (let ((layer-deregistered (u:href deregistered layer)))
        (unless (zerop (hash-table-count layer-deregistered))
          (u:do-hash-keys (k layer-deregistered)
            (remhash k (u:href active layer))
            (remhash k (u:href registered layer))
            (remove-collider-contacts system k)
            (remhash k layer-deregistered)))))))

(defun compute-collisions ()
  (let ((system (collision-system (current-scene =context=))))
    (compute-collisions/active system)
    (compute-collisions/registered system)
    (compute-collisions/deregistered system)))
