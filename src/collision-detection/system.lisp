(in-package #:%pyx.collision-detection)

(defstruct (system (:constructor %make-system)
                   (:conc-name nil)
                   (:predicate nil)
                   (:copier nil))
  spec
  (registered (u:dict #'eq))
  (deregistered (u:dict #'eq))
  (active (u:dict #'eq))
  (contacts (u:dict #'eq))
  (callback-entities (u:dict #'eq))
  (buffer (make-array 8 :adjustable t :fill-pointer t)))

(defun make-collision-system (plan-name)
  (a:if-let ((spec (u:href meta:=collider-plans= plan-name)))
    (let ((system (%make-system :spec spec)))
      (dolist (layer (layers spec))
        (setf (u:href (registered system) layer) (u:dict #'eq)
              (u:href (deregistered system) layer) (u:dict #'eq)
              (u:href (active system) layer) (u:dict #'eq)))
      system)
    (error "Collider plan ~s not found." plan-name)))

(defun get-collision-targets (targets collider)
  (a:when-let ((target (u:href targets (c/collider:target collider))))
    (u:hash-keys target)))

(defun register-collider (collider layer)
  (let* ((system (scene:collision-system (ctx:current-scene)))
         (registered (registered system)))
    (unless (u:href registered layer)
      (error "Collider ~s has a layer that is not in the scene's collider ~
              plan."
             collider))
    (setf (u:href registered layer collider) collider)))

(defun deregister-collider (collider layer)
  (let* ((system (scene:collision-system (ctx:current-scene)))
         (deregistered (deregistered system)))
    (setf (u:href deregistered layer collider) collider)))

(defun collider-contact-p (system collider1 collider2)
  (assert (not (eq collider1 collider2)))
  (let ((contacts (contacts system)))
    (when (u:href contacts collider1)
      (u:href contacts collider1 collider2))))

(defun collider-contact-enter (system collider1 collider2)
  (assert (not (eq collider1 collider2)))
  (let ((contacts (contacts system)))
    (unless (u:href contacts collider1)
      (setf (u:href contacts collider1) (u:dict #'eq)))
    (setf (u:href contacts collider1 collider2) collider2)
    (unless (u:href contacts collider2)
      (setf (u:href contacts collider2) (u:dict #'eq)))
    (setf (u:href contacts collider2 collider1) collider1)
    (%on-collision-enter collider1 collider2)
    (%on-collision-enter collider2 collider1)))

(defun collider-contact-continue (collider1 collider2)
  (assert (not (eq collider1 collider2)))
  (%on-collision-continue collider1 collider2)
  (%on-collision-continue collider2 collider1))

(defun collider-contact-exit (system collider1 collider2)
  (assert (not (eq collider1 collider2)))
  (let ((contacts (contacts system)))
    (a:when-let ((table2 (u:href contacts collider1)))
      (remhash collider2 table2)
      (when (zerop (hash-table-count table2))
        (remhash collider1 contacts)))
    (a:when-let ((table1 (u:href contacts collider2)))
      (remhash collider1 table1)
      (when (zerop (hash-table-count table1))
        (remhash collider2 contacts)))
    (%on-collision-exit collider1 collider2)
    (%on-collision-exit collider2 collider1)))

(defun remove-collider-contacts (system collider)
  (let ((contacts (contacts system)))
    (a:when-let ((colliders (u:href contacts collider)))
      (u:do-hash-keys (k colliders)
        (when (collider-contact-p system collider k)
          (collider-contact-exit system collider k))))))

(defun compute-collider-contact (system collider1 collider2)
  (when (and (ent:has-component-p collider1 'c/collider:collider)
             (ent:has-component-p collider2 'c/collider:collider))
    (a:when-let ((shape1 (c/collider:shape collider1))
                 (shape2 (c/collider:shape collider2)))
      (let ((collided-p (collide-p shape1 shape2))
            (contact-p (collider-contact-p system collider1 collider2)))
        (cond
          ((and collided-p contact-p)
           (collider-contact-continue collider1 collider2))
          ((and collided-p (not contact-p))
           (collider-contact-enter system collider1 collider2))
          ((and (not collided-p) contact-p)
           (collider-contact-exit system collider1 collider2)))))))

(defun compute-collisions/active (system)
  (let* ((active (active system))
         (buffer (buffer system)))
    (dolist (collider1-layer (layers (spec system)))
      (dolist (collider2-layer (u:href (plan (spec system)) collider1-layer))
        (if (eq collider1-layer collider2-layer)
            (a:when-let ((colliders (u:href active collider1-layer)))
              (setf (fill-pointer buffer) 0)
              (u:do-hash-keys (k colliders)
                (vector-push-extend k buffer))
              (when (>= (length buffer) 2)
                (a:map-combinations
                 (lambda (x)
                   (compute-collider-contact system (aref x 0) (aref x 1)))
                 buffer
                 :length 2
                 :copy nil)))
            (u:do-hash-keys (k1 (u:href active collider1-layer))
              (u:do-hash-keys (k2 (u:href active collider2-layer))
                (compute-collider-contact system k1 k2))))))))

(defun compute-collisions/registered (system)
  (let* ((active (active system))
         (registered (registered system)))
    (dolist (c1-layer (layers (spec system)))
      (let ((layer-registered (u:href registered c1-layer)))
        (u:do-hash-keys (c1 layer-registered)
          (remhash c1 layer-registered)
          (unless (u:href active c1)
            (let ((c2-layers (u:href (plan (spec system)) c1-layer)))
              (dolist (c2-layer c2-layers)
                (u:do-hash-keys (c2 (u:href active c2-layer))
                  (compute-collider-contact system c1 c2)))
              (setf (u:href active c1-layer c1) c1))))))))

(defun compute-collisions/deregistered (system)
  (let* ((active (active system))
         (registered (registered system))
         (deregistered (deregistered system)))
    (dolist (layer (layers (spec system)))
      (let ((layer-deregistered (u:href deregistered layer)))
        (unless (zerop (hash-table-count layer-deregistered))
          (u:do-hash-keys (k layer-deregistered)
            (remhash k (u:href active layer))
            (remhash k (u:href registered layer))
            (remove-collider-contacts system k)
            (remhash k layer-deregistered)))))))

(defun compute-collisions ()
  (let ((system (scene:collision-system (ctx:current-scene))))
    (compute-collisions/active system)
    (compute-collisions/registered system)
    (compute-collisions/deregistered system)))
