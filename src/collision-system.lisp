(in-package #:ndjinn)

(defstruct (collision-system
            (:constructor %make-collision-system)
            (:predicate nil)
            (:copier nil))
  (spec (%make-collision-plan-spec) :type collision-plan-spec)
  (registered (u:dict #'eq) :type hash-table)
  (deregistered (u:dict #'eq) :type hash-table)
  (active (u:dict #'eq) :type hash-table)
  (contacts (u:dict #'eq) :type hash-table)
  (buffer (make-array 8 :fill-pointer 0 :adjustable t) :type vector))

(defun make-collision-system (plan-name)
  (u:if-let ((spec (u:href =meta/collision-plans= plan-name)))
    (let* ((system (%make-collision-system :spec spec))
           (registered (collision-system-registered system))
           (deregistered (collision-system-deregistered system))
           (active (collision-system-active system)))
      (dolist (layer (collision-plan-spec-layers spec))
        (setf (u:href registered layer) (u:dict #'eq)
              (u:href deregistered layer) (u:dict #'eq)
              (u:href active layer) (u:dict #'eq)))
      system)
    (error "Collider plan ~s not found." plan-name)))

(defun register-collider (collider layer)
  (let* ((system (scene-collision-system (current-scene =context=)))
         (registered (collision-system-registered system)))
    (unless (u:href registered layer)
      (error "Collider ~s has a layer that is not in the scene's collider ~
              plan."
             collider))
    (setf (u:href registered layer collider) collider)))

(defun collider-contact-p (system collider1 collider2)
  (declare (optimize speed))
  (let ((contacts (collision-system-contacts system)))
    (when (u:href contacts collider1)
      (u:href contacts collider1 collider2))))

(defun collider-contact-enter (system collider1 collider2)
  (declare (optimize speed))
  (let ((contacts (collision-system-contacts system)))
    (unless (u:href contacts collider1)
      (setf (u:href contacts collider1) (u:dict #'eq)))
    (setf (u:href contacts collider1 collider2) collider2)
    (unless (u:href contacts collider2)
      (setf (u:href contacts collider2) (u:dict #'eq)))
    (setf (u:href contacts collider2 collider1) collider1)
    (%on-collision-enter collider1 collider2)
    (%on-collision-enter collider2 collider1)))

(defun collider-contact-exit (system collider1 collider2)
  (declare (optimize speed))
  (let ((contacts (collision-system-contacts system)))
    (u:when-let ((table2 (u:href contacts collider1)))
      (remhash collider2 table2)
      (when (zerop (hash-table-count table2))
        (remhash collider1 contacts)))
    (u:when-let ((table1 (u:href contacts collider2)))
      (remhash collider1 table1)
      (when (zerop (hash-table-count table1))
        (remhash collider2 contacts)))
    (%on-collision-exit collider1 collider2)
    (%on-collision-exit collider2 collider1)))

(defun collider-contact-continue (collider1 collider2)
  (declare (optimize speed))
  (%on-collision-continue collider1 collider2)
  (%on-collision-continue collider2 collider1))

(defun remove-collider-contacts (system collider)
  (let ((contacts (collision-system-contacts system)))
    (u:when-let ((colliders (u:href contacts collider)))
      (u:do-hash-keys (k colliders)
        (when (collider-contact-p system collider k)
          (collider-contact-exit system collider k))))))

(defun deregister-collider (collider layer)
  (let* ((system (scene-collision-system (current-scene =context=)))
         (deregistered (collision-system-deregistered system)))
    (remove-collider-contacts system collider)
    (setf (u:href deregistered layer collider) collider)))

(defun compute-collider-contact (system collider1 collider2)
  (declare (optimize speed))
  (u:when-let ((shape1 (collider/shape collider1))
               (shape2 (collider/shape collider2)))
    (let ((collided-p (collide-p shape1 shape2))
          (contact-p (collider-contact-p system collider1 collider2)))
      (cond
        ((and collided-p contact-p)
         (collider-contact-continue collider1 collider2))
        ((and collided-p (not contact-p))
         (collider-contact-enter system collider1 collider2))
        ((and (not collided-p) contact-p)
         (collider-contact-exit system collider1 collider2))))))

(defun compute-collisions/active (system)
  (let* ((active (collision-system-active system))
         (buffer (collision-system-buffer system))
         (spec (collision-system-spec system))
         (table (collision-plan-spec-table spec)))
    (dolist (collider1-layer (collision-plan-spec-layers spec))
      (dolist (collider2-layer (u:href table collider1-layer))
        (if (eq collider1-layer collider2-layer)
            (u:when-let ((colliders (u:href active collider1-layer)))
              (setf (fill-pointer buffer) 0)
              (u:do-hash-keys (k colliders)
                (vector-push-extend k buffer))
              (when (>= (length buffer) 2)
                (u:map-combinations
                 (lambda (x)
                   (compute-collider-contact system (aref x 0) (aref x 1)))
                 buffer
                 :length 2
                 :copy nil)))
            (u:do-hash-keys (k1 (u:href active collider1-layer))
              (u:do-hash-keys (k2 (u:href active collider2-layer))
                (compute-collider-contact system k1 k2))))))))

(defun compute-collisions/registered (system)
  (declare (optimize speed))
  (let* ((active (collision-system-active system))
         (registered (collision-system-registered system))
         (spec (collision-system-spec system))
         (table (collision-plan-spec-table spec)))
    (dolist (c1-layer (collision-plan-spec-layers spec))
      (let ((layer-registered (u:href registered c1-layer)))
        (u:do-hash-keys (c1 layer-registered)
          (remhash c1 layer-registered)
          (unless (u:href active c1)
            (let ((c2-layers (u:href table c1-layer)))
              (dolist (c2-layer c2-layers)
                (u:do-hash-keys (c2 (u:href active c2-layer))
                  (compute-collider-contact system c1 c2)))
              (setf (u:href active c1-layer c1) c1))))))))

(defun compute-collisions/deregistered (system)
  (declare (optimize speed))
  (let* ((active (collision-system-active system))
         (registered (collision-system-registered system))
         (deregistered (collision-system-deregistered system)))
    (dolist (layer (collision-plan-spec-layers (collision-system-spec system)))
      (let ((layer-deregistered (u:href deregistered layer)))
        (unless (zerop (hash-table-count layer-deregistered))
          (u:do-hash-keys (k layer-deregistered)
            (remhash k (u:href active layer))
            (remhash k (u:href registered layer))
            (remove-collider-contacts system k)
            (remhash k layer-deregistered)))))))

(defun compute-collisions ()
  (declare (optimize speed))
  (let ((system (scene-collision-system (current-scene =context=))))
    (compute-collisions/active system)
    (compute-collisions/registered system)
    (compute-collisions/deregistered system)))
